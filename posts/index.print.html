<!DOCTYPE html>
<html lang="zh-cn" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.147.1">
    <meta name="generator" content="Relearn 7.6.1+d7685ad3986c906cb10e62854fca7c730df4bf58">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Posts :: Pluto417-Qing&#39;s Blog">
    <meta property="og:url" content="http://localhost:1313/posts/index.html">
    <meta property="og:site_name" content="Pluto417-Qing&#39;s Blog">
    <meta property="og:title" content="Posts :: Pluto417-Qing&#39;s Blog">
    <meta property="og:locale" content="zh_cn">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Posts :: Pluto417-Qing&#39;s Blog">
    <meta itemprop="datePublished" content="2025-05-13T00:00:00+00:00">
    <meta itemprop="dateModified" content="2025-05-13T00:00:00+00:00">
    <title>Posts :: Pluto417-Qing&#39;s Blog</title>
    <link href="http://localhost:1313/posts/index.html" rel="canonical" type="text/html" title="Posts :: Pluto417-Qing&#39;s Blog">
    <link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="Posts :: Pluto417-Qing&#39;s Blog">
    <link href="/images/logo.svg?1747202925" rel="icon" type="image/svg+xml">
    <link href="/fonts/fontawesome/css/fontawesome-all.min.css?1747202925" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/fonts/fontawesome/css/fontawesome-all.min.css?1747202925" rel="stylesheet"></noscript>
    <link href="/css/perfect-scrollbar/perfect-scrollbar.min.css?1747202925" rel="stylesheet">
    <link href="/css/theme.css?1747202925" rel="stylesheet">
    <link href="/css/format-print.css?1747202925" rel="stylesheet" id="R-format-style">
    <link href="/css/auto-complete/auto-complete.min.css?1747202925" rel="stylesheet">
    <script src="/js/auto-complete/auto-complete.min.js?1747202925" defer></script>
    <script src="/js/lunr/lunr.min.js?1747202925" defer></script>
    <script src="/js/lunr/lunr.stemmer.support.min.js?1747202925" defer></script>
    <script src="/js/lunr/lunr.multi.min.js?1747202925" defer></script>
    <script src="/js/lunr/lunr.zh.min.js?1747202925" defer></script>
    <script src="/js/search.js?1747202925" defer></script>
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = ``;
      window.relearn.path='\/posts\/index.html';
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..';
      window.relearn.absBaseUri='http:\/\/localhost:1313';
      window.relearn.contentLangs=['zh'];
      window.relearn.index_js_url="/searchindex.zh-cn.js?1747202925";
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // variant stuff
      window.relearn.themevariants = [ 'auto', 'relearn-light', 'relearn-dark' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
      // translations
      window.T_Copy_to_clipboard = `复制到剪贴板`;
      window.T_Copied_to_clipboard = `复制到剪贴板！`;
      window.T_Copy_link_to_clipboard = `将链接复制到剪贴板`;
      window.T_Link_copied_to_clipboard = `链接复制到剪贴板！`;
      window.T_Reset_view = `重置视图`;
      window.T_View_reset = `查看重置！`;
      window.T_No_results_found = `找不到"{0}"的结果`;
      window.T_N_results_found = `为"{0}"找到 {1} 个结果`;
    </script>
    <link href="/css/custom.css?1747202925" rel="stylesheet">
  </head>
  <body class="mobile-support print" data-url="/posts/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="导航 (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="目录 (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"> 
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList">
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/index.html"><span itemprop="name">Hello World</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li>
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">Posts</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/posts/index.print.html" title="打印整章 (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/index.html" title="Hello World (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/posts/lab/index.html" title="6.s081 xv6 Lab (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="更多"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable posts" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="posts">Posts</h1>


  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> May 13, 2025
  </footer>
</article>
          <section>
            <h1 class="a11y-only">Posts 的子部分</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="6s081-xv6-lab">6.s081 xv6 Lab</h1>

<ul>
<li>Lab 1：Unix Utilities</li>
<li>Lab 2: System Calls</li>
<li>Lab 3：Page Tables</li>
<li>Lab 4: Traps</li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> May 13, 2025
  </footer>
</article>
          <section>
            <h1 class="a11y-only">6.s081 xv6 Lab 的子部分</h1>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E5%AE%9E%E9%AA%8C/index.html">实验</a></li>
    <li><a class="term-link" href="/tags/%E6%8E%A2%E7%B4%A2/index.html">探索</a></li>
  </ul>
</div>
  </header>

<h1 id="lab-1unix-utilities">Lab 1：Unix Utilities</h1>

<p>Lab1 主要关于如何使用操作系统像用户程序提供的API来编写程序，也就是所谓的系统调用。使用系统调用可以方便使用操作系统封装的很多功能。完成实验之前，先了解一些预备知识。</p>
<h4 id="预备知识">预备知识</h4>
<h5 id="1-如何获取命令行参数">1. 如何获取命令行参数</h5>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){}</span></span></span></code></pre></div>
<p>main函数有两个参数。参数argc是一个整数，储存传入的命令行参数的个数。而参数argv是一个字符串数组，以字符串的形式存储传入的参数。argv[0]处存的是命令名称，往后才是参数。</p>
<h5 id="2-系统调用的底层实现细节">2. 系统调用的底层实现细节</h5>
<p>系统调用是如何实现的，比如为什么可以在sleep.c中直接使用sleep函数，那么sleep函数后面的实现细节是什么？我们可以通过gdb来观察一下。</p>
<p>首先读入user/sleep.c文件，并在sleep的main函数处设置断点。按c运行到main函数入口处停下。



<figure class="figure-container">
    <img src="/images/lab1/file.png" alt="image-20250513191516713" class="clickable-image">
    
</figure>



<style>
.figure-container {
    cursor: pointer;
    display: block;
    text-align: center;
    margin: 1em 0;
    width: 400px;
    height: 200px;
    margin-left: auto;
    margin-right: auto;
    background-color: #f8f9fa;
    border-radius: 4px;
    overflow: hidden;
}

.figure-container img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    padding: 10px;
}

.figure-container figcaption {
    margin-top: 0.5em;
    font-size: 0.9em;
    color: #666;
    text-align: center;
}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.9);
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

.modal.show {
    opacity: 1;
}

.modal-content {
    margin: auto;
    display: block;
    max-width: 90%;
    max-height: 90%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.7);
    transition: transform 0.3s ease-in-out;
    object-fit: contain;
}

.modal.show .modal-content {
    transform: translate(-50%, -50%) scale(1);
}

.close {
    position: absolute;
    top: 15px;
    right: 35px;
    color: #f1f1f1;
    font-size: 40px;
    font-weight: bold;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.3s;
}

.close:hover {
    opacity: 1;
}

.clickable-image {
    transition: transform 0.2s;
}

.clickable-image:hover {
    transform: scale(1.02);
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const images = document.querySelectorAll('.clickable-image');
    
    images.forEach(function(img) {
        img.addEventListener('click', function(e) {
            e.preventDefault();
            openImageModal(this);
        });
    });
});

function openImageModal(img) {
    var modal = document.createElement('div');
    modal.className = 'modal';
    
    var modalImg = document.createElement('img');
    modalImg.className = 'modal-content';
    modalImg.src = img.src;
    modalImg.alt = img.alt;
    
    var closeBtn = document.createElement('span');
    closeBtn.className = 'close';
    closeBtn.innerHTML = '&times;';
    
    closeBtn.onclick = function() {
        closeModal(modal);
    }
    
    modal.onclick = function(event) {
        if (event.target === modal) {
            closeModal(modal);
        }
    }
    
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            closeModal(modal);
        }
    });
    
    modal.appendChild(modalImg);
    modal.appendChild(closeBtn);
    document.body.appendChild(modal);
    
    requestAnimationFrame(function() {
        modal.style.display = 'block';
        requestAnimationFrame(function() {
            modal.classList.add('show');
        });
    });
}

function closeModal(modal) {
    modal.classList.remove('show');
    setTimeout(function() {
        if (modal.parentNode) {
            modal.parentNode.removeChild(modal);
        }
    }, 300);
}
</script>
 
</p>
<p>进入sleep函数查看



<figure class="figure-container">
    <img src="/images/lab1/sleep.png" alt="sleep" class="clickable-image">
    
</figure>

 
</p>
<p>发现进入了usys.S文件，注意高亮处到ret前的两条指令。



<figure class="figure-container">
    <img src="/images/lab1/usys.png" alt="usys" class="clickable-image">
    
</figure>

 
</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">li a7, SYS_sleep
</span></span><span class="line"><span class="cl">ecall</span></span></code></pre></div>
<p>在kernel/syscall.h文件中查看SYS_sleep的值为13，所以这两条语句的作用是把要调用的系统调用函数的编号作为参数传入a7寄存器，然后执行ecall指令，该指令将处理器模式切换为内核模式（在用户模式下是不能调用系统调用函数的）。</p>
<p>继续运行，发现到达kernel/syscall函数内部，此时num的值为13，可以发现该函数通过syscalls函数数组根据传入的编号调用对应的系统调用函数。



<figure class="figure-container">
    <img src="/images/lab1/syscall.png" alt="syscall" class="clickable-image">
    
</figure>

 
</p>
<p>继续运行，最终来到sleep系统调用的本体，sys_sleep函数，该函数位于kernel/sysproc.c文件内，该文件里是常用的系统调用函数，例如fork,exit等.



<figure class="figure-container">
    <img src="/images/lab1/sysproc.png" alt="sysproc" class="clickable-image">
    
</figure>

 
</p>
<h3 id="sleepeasy">Sleep(easy)</h3>
<div style="background-color:rgb(15, 184, 251); border-left: 4px solid rgb(212, 251, 15); padding: 15px; margin: 20px 0; border-radius: 4px;">
<strong>题目要求：</strong><br>
Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c.
</div>
直接调用sleep库函数即可。用户模式可调用的函数接口定义在user/user.h，系统调用的具体细节见上文。
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/types.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/stat.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;user/user.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果没有给命令参数，打印错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&#34;Usage: sleep num</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">time</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// 将命令参数转换为整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">sleep</span><span class="p">(</span><span class="n">time</span><span class="p">);</span> <span class="c1">// 调用sleep函数，等待指定时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	<span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
<h3 id="pingpongeasy">Pingpong(easy)</h3>
<div style="background-color:rgb(15, 184, 251); border-left: 4px solid rgb(212, 251, 15); padding: 15px; margin: 20px 0; border-radius: 4px;">
<strong>题目要求：</strong><br>
Write a program that uses UNIX system calls to ''ping-pong'' a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print "&lt;pid&gt;: received ping", where &lt;pid&gt; is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print "&lt;pid&gt;: received pong", and exit. Your solution should be in the file user/pingpong.c.
</div>
<p>看题知父进程和子进程都要往管道里写数据，也要从管道里读数据。所以需要创建两对管道，为什么？因为一个进程只能使用一对管道的一端用来读或者写，不用的那一端要及时关闭。如果不关闭就会导致read或者write阻塞，一直无法结束，这也是为什么需要创建两对管道的原因。</p>
<p>同时，需要注意的是，fork后子进程会复制得到父进程的管道，所以fork以后子进程有两对管道，父进程也有两对管道。而它们分别只用到各自的4个管道中的两个分别作为读写端。所以一开始关闭不用的那一端，另一端的管道才能被父进程或者子进程使用。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/types.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/stat.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;user/user.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建两个管道，一个父进程向子进程发送消息，另一个相反
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">p1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">p2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pipe</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pipe</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="c1">// 缓冲区，用于存储发送的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">char</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="s">&#34;c&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>	<span class="c1">// 创建一个子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="nf">close</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>	<span class="c1">// 关闭子进程的读取管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">close</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>	<span class="c1">// 关闭子进程的写入管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="nf">read</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">buf</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>	<span class="c1">// 从父进程读取消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d: received ping</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">		<span class="nf">write</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">buf</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>	<span class="c1">// 向父进程写入消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="nf">close</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>	<span class="c1">// 关闭子进程的读取管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">close</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>	<span class="c1">// 关闭子进程的写入管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="nf">close</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>   <span class="c1">// 关闭父进程的写入管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">close</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>   <span class="c1">// 关闭父进程的读取管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="nf">write</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>	<span class="c1">// 向子进程写入消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">read</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">buf</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>	<span class="c1">// 从子进程读取消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d: received pong</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">close</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>	<span class="c1">// 关闭父进程的读取管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">close</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>	<span class="c1">// 关闭父进程的写入管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
<h3 id="primes-moderatehard">primes (moderate)/(hard)</h3>
<div style="background-color:rgb(15, 184, 251); border-left: 4px solid rgb(212, 251, 15); padding: 15px; margin: 20px 0; border-radius: 4px;">
<strong>题目要求：</strong><br>
Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c.
</div>
题目有几个要点：
<ul>
<li>
<p>是管道资源有限的问题，必须及时关闭不用的管道</p>
</li>
<li>
<p>递归调用筛选素数的函数</p>
</li>
<li>
<p>父进程负责筛选素数，子进程负责打印素数</p>
</li>
</ul>
<p>递归调用的筛选素数的函数主要思路是：参数为父进程的管道，该函数从该管道读取父进程写入的数，打印并保存第一个数，然后再创建一个新的管道，并创建子进程，继续从旧管道读取数，把第一个数的倍数筛掉后的数写入到新的管道。然后递归调用该函数，直到管道中没有数据。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/types.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/stat.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;user/user.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">primes</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldPipe</span><span class="p">[]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">primes</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// 递归处理素数筛选
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">35</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>  <span class="c1">// 向管道写入数字2-35
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>  <span class="c1">// 向管道写入0，表示结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// 及时关闭管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;fork error</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">primes</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldPipe</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">oldPipe</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">// 不再使用的管道一定要及时关掉，不然会导致运行失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">read</span><span class="p">(</span><span class="n">oldPipe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>  <span class="c1">// 从管道读取数字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果读取到0，表示没有数字了，结束进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;prime %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// 打印当前素数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//创建该进程与子进程的pipe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">newPipe</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pipe</span><span class="p">(</span><span class="n">newPipe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 子进程       
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">primes</span><span class="p">(</span><span class="n">newPipe</span><span class="p">);</span>  <span class="c1">// 递归处理素数筛选
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>   
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">newPipe</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="nf">read</span><span class="p">(</span><span class="n">oldPipe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">&amp;</span><span class="n">num</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果num能被p整除，则写入新的管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nf">write</span><span class="p">(</span><span class="n">newPipe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">write</span><span class="p">(</span><span class="n">newPipe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>  <span class="c1">// 向新的管道写入0，表示结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 及时关闭管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">close</span><span class="p">(</span><span class="n">oldPipe</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>    <span class="c1">// 关闭旧的管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">close</span><span class="p">(</span><span class="n">newPipe</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>   <span class="c1">// 关闭新的管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;fork error</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
<h3 id="find-moderate">find (moderate)</h3>
<div style="background-color:rgb(15, 184, 251); border-left: 4px solid rgb(212, 251, 15); padding: 15px; margin: 20px 0; border-radius: 4px;">
<strong>题目要求：</strong><br>
Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user/find.c.
</div>
首先查看user/ls.c中读取目录的方法。可知文件/目录的信息都储存在stat结构体中，通过查看其type属性的值，就可以知道是文件还是目录。。
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">switch</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">type</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">T_FILE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">T_DIR</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span></span></span></code></pre></div>
<p>回到find.c中,先打开目录,然后遍历目录中的文件,如果是文件,则比较是否和要找的文件名相同,如果相同则打印文件名。如果是目录,则递归调用find函数进入目录内查找。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/types.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/stat.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;user/user.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/fs.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span><span class="o">*</span> <span class="nf">fmtname</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果没有输入参数，则输出错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#34;Usage: find env target</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">find</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">env</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span> <span class="c1">// 用于存储文件状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">dirent</span> <span class="n">de</span><span class="p">;</span> <span class="c1">// 用于存储目录项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span> <span class="c1">// 用于存储文件描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果打开文件失败，则输出错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#34;find: cannot open %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nf">fstat</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果获取文件状态失败，则输出错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#34;find: cannot stat %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">switch</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">type</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">T_FILE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果文件类型为文件，则比较文件名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="nf">fmtname</span><span class="p">(</span><span class="n">env</span><span class="p">),</span> <span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">env</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">T_DIR</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果文件类型为目录，则复制目录路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="c1">// 将p指向buf的末尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span> <span class="c1">// 在buf的末尾添加一个&#39;/&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span><span class="p">(</span><span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">de</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果目录项为空，则跳过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">inum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="nf">memmove</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">DIRSIZ</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">p</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">strcmp</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#34;..&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 如果目录项不是当前目录和父目录，则递归查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="nf">find</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">char</span><span class="o">*</span> <span class="nf">fmtname</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Find first character after last slash.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">path</span><span class="o">+</span><span class="nf">strlen</span><span class="p">(</span><span class="n">path</span><span class="p">);</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">path</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span> <span class="n">p</span><span class="o">--</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Return blank-padded name.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nf">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">DIRSIZ</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memmove</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="nf">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">DIRSIZ</span><span class="o">-</span><span class="nf">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
<h3 id="xargs-moderate">xargs (moderate)</h3>
<div style="background-color:rgb(15, 184, 251); border-left: 4px solid rgb(212, 251, 15); padding: 15px; margin: 20px 0; border-radius: 4px;">
<strong>题目要求：</strong><br>
Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user/xargs.c.
</div>
为什么要使用xargs,因为有些命令行工具比如rm，它只能通过命令行参数接收文件名（如 rm file1 file2），而不能从管道（|）读取输入。所以这时就需要使用xargs来转换。
<p>xargs命令的实现思路:</p>
<ol>
<li>
<p>主函数main接收命令行参数:</p>
<ul>
<li>检查参数数量,至少需要一个命令参数</li>
<li>将命令行参数复制到新数组newArgv中,为后续添加标准输入内容预留空间</li>
</ul>
</li>
<li>
<p>xargs函数实现核心功能:</p>
<ul>
<li>
<p>从标准输入读取内容,按行处理</p>
</li>
<li>
<p>每读取一行完整内容后:</p>
<p>a. fork一个子进程</p>
<p>b. 在子进程中:</p>
<ul>
<li>将读取的行内容作为最后一个参数</li>
<li>执行目标命令</li>
</ul>
<p>c. 父进程等待子进程结束,继续处理下一行</p>
</li>
<li>
<p>通过这种方式,实现了将标准输入的每一行作为参数执行命令</p>
</li>
</ul>
</li>
</ol>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/types.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/stat.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;user/user.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/fs.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;kernel/param.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">xargs</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果没有输入参数，则输出错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#34;Usage: xargs cmd [arg]</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">newArgv</span><span class="p">[</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将命令行参数复制到newArgv中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">newArgv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">xargs</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argc</span><span class="p">,</span> <span class="n">newArgv</span><span class="p">);</span> <span class="c1">// 调用xargs函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">xargs</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXARG</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="nf">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">))){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果buf[n]不是换行符，则继续读取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">n</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span> <span class="c1">// 将buf作为最后一个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 将argv[argc]设置为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="nf">exec</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="n">argv</span><span class="p">);</span> <span class="c1">// 执行命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&#34;execv error</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> <span class="c1">// 如果exec失败，则输出错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
<h3 id="测评记录">测评记录</h3>



<figure class="figure-container">
    <img src="/images/lab1/Lab1-grading.png" alt="syscall" class="clickable-image">
    
</figure>

 


  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> May 13, 2025
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E5%AE%9E%E9%AA%8C/index.html">实验</a></li>
    <li><a class="term-link" href="/tags/%E6%8E%A2%E7%B4%A2/index.html">探索</a></li>
  </ul>
</div>
  </header>

<h1 id="lab-2-system-calls">Lab 2: System Calls</h1>

<p>Lab1 是关于使用系统调用，Lab2则要我们自己写系统调用。</p>
<h3 id="system-call-tracing-moderate">System call tracing (moderate)</h3>
<div style="background-color:rgb(15, 184, 251); border-left: 4px solid rgb(212, 251, 15); padding: 15px; margin: 20px 0; border-radius: 4px;">
<strong>题目要求：</strong><br>
In this assignment you will add a system call tracing feature that may help you when debugging later labs. You'll create a new trace system call that will control tracing. It should take one argument, an integer "mask", whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 << SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call's number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don't need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.
</div>
由Lab1我们知道,系统调用的过程是,首先运行syscall函数,然后进入内核态,内核态运行sysproc.c中的系统调用函数.
所有我们首先需要在kernel/sysproc.c中定义一个新的系统调用函数sys_trace。
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">uint64</span>
</span></span><span class="line"><span class="cl"><span class="nf">sys_trace</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span> <span class="c1">// 系统调用参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nf">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 通过argint函数获取参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果参数错误，返回-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span> <span class="c1">// 获取当前进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span> <span class="o">-&gt;</span> <span class="n">traceMask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span> <span class="c1">// 设置进程的traceMask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
<p>在这个函数中我们会获取函数参数,然后设置proc结构体的traceMask字段。因为每个系统调用的信息都可能会被打印，而是否打印是由traceMask字段控制的。所有具体的打印代码应该放在syscall函数中,因为每个系统调用都必须经过该函数。
所以接下来在syscall函数中加入打印代码:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">syscall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">syscallNames</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;&#34;</span><span class="p">,</span><span class="s">&#34;fork&#34;</span><span class="p">,</span> <span class="s">&#34;exit&#34;</span><span class="p">,</span> <span class="s">&#34;wait&#34;</span><span class="p">,</span> <span class="s">&#34;pipe&#34;</span><span class="p">,</span> <span class="s">&#34;read&#34;</span><span class="p">,</span> <span class="s">&#34;kill&#34;</span><span class="p">,</span><span class="s">&#34;exec&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fstat&#34;</span><span class="p">,</span> <span class="s">&#34;chdir&#34;</span><span class="p">,</span> <span class="s">&#34;dup&#34;</span><span class="p">,</span> <span class="s">&#34;getpid&#34;</span><span class="p">,</span> <span class="s">&#34;sbrk&#34;</span><span class="p">,</span> <span class="s">&#34;sleep&#34;</span><span class="p">,</span> <span class="s">&#34;uptime&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;open&#34;</span><span class="p">,</span> <span class="s">&#34;write&#34;</span><span class="p">,</span> <span class="s">&#34;mknod&#34;</span><span class="p">,</span> <span class="s">&#34;unlink&#34;</span><span class="p">,</span> <span class="s">&#34;link&#34;</span><span class="p">,</span> <span class="s">&#34;mkdir&#34;</span><span class="p">,</span> <span class="s">&#34;close&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;trace&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span> <span class="c1">// 系统调用名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">num</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a7</span><span class="p">;</span> <span class="c1">// 获取系统调用编号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="nf">NELEM</span><span class="p">(</span><span class="n">syscalls</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">syscalls</span><span class="p">[</span><span class="n">num</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span> <span class="o">=</span> <span class="n">syscalls</span><span class="p">[</span><span class="n">num</span><span class="p">]();</span> <span class="c1">// 执行系统调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mask</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="n">traceMask</span><span class="p">;</span> <span class="c1">// 获取traceMask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)){</span> <span class="c1">// 如果traceMask不为-1且num在mask中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d: syscall %s -&gt; %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span><span class="n">syscallNames</span><span class="p">[</span><span class="n">num</span><span class="p">],</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span><span class="p">);</span> <span class="c1">// 打印系统调用信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d %s: unknown sys call %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span> <span class="c1">// 打印错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 设置返回值为-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
<p>然后在kernel/proc.c中的fork函数中加入下面一行代码,将父进程的traceMask复制到子进程中:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">np</span><span class="o">-&gt;</span><span class="n">traceMask</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">traceMask</span><span class="p">;</span></span></span></code></pre></div>
<h3 id="sysinfo-moderate">Sysinfo (moderate)</h3>
<div style="background-color:rgb(15, 184, 251); border-left: 4px solid rgb(212, 251, 15); padding: 15px; margin: 20px 0; border-radius: 4px;">
<strong>题目要求：</strong><br>
In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints "sysinfotest: OK".
</div>
<p>首先查看struct sysinfo的定义:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">sysinfo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint64</span> <span class="n">freemem</span><span class="p">;</span>   <span class="c1">// amount of free memory (bytes)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uint64</span> <span class="n">nproc</span><span class="p">;</span>     <span class="c1">// number of process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span></span></span></code></pre></div>
<p>接下来需要在kernel/sysproc.c中定义sys_sysinfo函数,函数需要完成两个任务,首先如何获取空闲内存的值，
第二个任务如何获取空闲的进程数量。</p>
<p>为获取空闲的内存数量,在kernel/kalloc.c中定义一个函数calFreeMem,该函数会遍历空闲链表,并计算空闲内存大小。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">uint64</span> 
</span></span><span class="line"><span class="cl"><span class="nf">calFreeMem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint64</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">r</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span> <span class="c1">// 获取空闲链表头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span><span class="p">(</span><span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">num</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">;</span> <span class="c1">// 累加空闲页大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">// 指向下一个空闲页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">num</span><span class="p">;</span> <span class="c1">// 返回空闲内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
<p>为获取空闲的进程数量,在pro.c中定义一个辅助函数calUnusedProc,该函数会遍历proc数组,并计算UNSED状态的进程数量。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">calUnusedProc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nums</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历所有进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">UNUSED</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 如果进程状态不是UNUSED，则计数器加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">nums</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">nums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
<p>最后仿照kernel/file.c中的filestat函数,将struct sysinfo复制会用户空间:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="nf">copyout</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">syif</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">syif</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 将sysinfo结构体复制到用户空间      
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 如果复制失败，返回-1
</span></span></span></code></pre></div>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">uint64</span>
</span></span><span class="line"><span class="cl"><span class="nf">sys_sysinfo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">syif</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint64</span> <span class="n">sys</span><span class="p">;</span> <span class="c1">// user pointer to struct sysinfo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nf">argaddr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sys</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 通过argaddr函数获取参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// set the value of struct sysinfo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">syif</span><span class="p">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="nf">calUnusedProc</span><span class="p">();</span> <span class="c1">// 计算未使用进程数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">syif</span><span class="p">.</span><span class="n">freemem</span> <span class="o">=</span> <span class="nf">calFreeMem</span><span class="p">();</span> <span class="c1">// 计算空闲内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nf">copyout</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">syif</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">syif</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 将sysinfo结构体复制到用户空间      
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 如果复制失败，返回-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
<h3 id="测评记录">测评记录</h3>



<figure class="figure-container">
    <img src="/images/lab2/Lab2-grading.png" alt="syscall" class="clickable-image">
    
</figure>



<style>
.figure-container {
    cursor: pointer;
    display: block;
    text-align: center;
    margin: 1em 0;
    width: 400px;
    height: 200px;
    margin-left: auto;
    margin-right: auto;
    background-color: #f8f9fa;
    border-radius: 4px;
    overflow: hidden;
}

.figure-container img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    padding: 10px;
}

.figure-container figcaption {
    margin-top: 0.5em;
    font-size: 0.9em;
    color: #666;
    text-align: center;
}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.9);
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

.modal.show {
    opacity: 1;
}

.modal-content {
    margin: auto;
    display: block;
    max-width: 90%;
    max-height: 90%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.7);
    transition: transform 0.3s ease-in-out;
    object-fit: contain;
}

.modal.show .modal-content {
    transform: translate(-50%, -50%) scale(1);
}

.close {
    position: absolute;
    top: 15px;
    right: 35px;
    color: #f1f1f1;
    font-size: 40px;
    font-weight: bold;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.3s;
}

.close:hover {
    opacity: 1;
}

.clickable-image {
    transition: transform 0.2s;
}

.clickable-image:hover {
    transform: scale(1.02);
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const images = document.querySelectorAll('.clickable-image');
    
    images.forEach(function(img) {
        img.addEventListener('click', function(e) {
            e.preventDefault();
            openImageModal(this);
        });
    });
});

function openImageModal(img) {
    var modal = document.createElement('div');
    modal.className = 'modal';
    
    var modalImg = document.createElement('img');
    modalImg.className = 'modal-content';
    modalImg.src = img.src;
    modalImg.alt = img.alt;
    
    var closeBtn = document.createElement('span');
    closeBtn.className = 'close';
    closeBtn.innerHTML = '&times;';
    
    closeBtn.onclick = function() {
        closeModal(modal);
    }
    
    modal.onclick = function(event) {
        if (event.target === modal) {
            closeModal(modal);
        }
    }
    
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            closeModal(modal);
        }
    });
    
    modal.appendChild(modalImg);
    modal.appendChild(closeBtn);
    document.body.appendChild(modal);
    
    requestAnimationFrame(function() {
        modal.style.display = 'block';
        requestAnimationFrame(function() {
            modal.classList.add('show');
        });
    });
}

function closeModal(modal) {
    modal.classList.remove('show');
    setTimeout(function() {
        if (modal.parentNode) {
            modal.parentNode.removeChild(modal);
        }
    }, 300);
}
</script>
 


  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> May 13, 2025
  </footer>
</article>
          </section>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/svg/index.html">SVG</a></li>
    <li><a class="term-link" href="/tags/%E7%AC%94%E8%AE%B0/index.html">笔记</a></li>
  </ul>
</div>
  </header>

<h1 id="svg学习笔记">SVG学习笔记</h1>

<p>SVG（Scalable Vector Graphics）是一种基于XML的矢量图形格式。本专栏介绍自己学习svg过程中的一些笔记和重点，欢迎大家一起交流。</p>
<h2 id="什么是svg">什么是SVG？</h2>
<p>SVG是一种使用XML描述二维图形的文件格式。SVG图像在放大或改变尺寸的情况下其图形质量不会有所损失。</p>
<h2 id="基本形状">基本形状</h2>
<p>SVG支持多种基本形状：</p>
<ul>
<li>矩形 (rect)</li>
<li>圆形 (circle)</li>
<li>椭圆 (ellipse)</li>
<li>线条 (line)</li>
<li>折线 (polyline)</li>
<li>多边形 (polygon)</li>
<li>路径 (path)</li>
</ul>
<h2 id="示例">示例</h2>
<p>这里是一个简单的SVG示例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-svg" data-lang="svg"><span class="line"><span class="cl"><span class="nt">&lt;svg</span> <span class="na">width=</span><span class="s">&#34;100&#34;</span> <span class="na">height=</span><span class="s">&#34;100&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;circle</span> <span class="na">cx=</span><span class="s">&#34;50&#34;</span> <span class="na">cy=</span><span class="s">&#34;50&#34;</span> <span class="na">r=</span><span class="s">&#34;40&#34;</span> <span class="na">stroke=</span><span class="s">&#34;black&#34;</span> <span class="na">stroke-width=</span><span class="s">&#34;3&#34;</span> <span class="na">fill=</span><span class="s">&#34;red&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/svg&gt;</span></span></span></code></pre></div>
<p>这个示例创建了一个红色的圆，带有黑色边框。</p>
<h2 id="总结">总结</h2>
<p>SVG是一个强大的图形格式，特别适合用于网页设计。</p>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> Mar 21, 2024
  </footer>
</article>
          <section>
            <h1 class="a11y-only">SVG学习笔记 的子部分</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="svg图形绘制与展示的逻辑">SVG图形绘制与展示的逻辑</h1>

<p>之前写大作业小游戏的时候就遇到过要自己找图片资源，当时第一次接触SVG图像，根本不了解，最近决定好好学习一下SVG。</p>
<p>SVG是一种基于XML的矢量图形格式，它可以用来定义二维图形，且与常见的位图不同，缩放不会影响画质。因为它是用XML描述绘制图形的方法的，而不是像位图一样直接保存图片的单个像素点。</p>
<h4 id="关键概念">关键概念</h4>
<ol>
<li>画布 ：无穷大，是绘制图形的区域。</li>
<li>裁切层 ：控制显示区域的框，在画布上框选出特定的区域来显示。</li>
<li>SVG区域大小 ：大小在svg标签中设定。也是最后页面上显示图片的大小。</li>
</ol>
<h4 id="解释">解释</h4>
<p>在写SVG代码的时候一开始会创建一个SVG标签：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">svg</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;400&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;400&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">svg</span><span class="p">&gt;</span></span></span></code></pre></div>
<p>这个就是要显示的SVG区域的大小。而SVG图形的绘制是在画布上进行的，这个画布我们是看不见的，同时画布有无穷大。我们可以在画布上绘制任意的图形，但是最后显示的SVG图片大小是固定的，当画布上绘制的图形大小与SVG区域大小不一致时，我们怎么控制显示画布上哪一部分呢？这时候就要用到裁切层来在画布上选择特定的区域来显示。下面先介绍SVG的一些基础的概念。</p>
<h4 id="坐标区域">坐标区域</h4>
<p>SVG坐标区域的原点在左上角，向右为x轴正方向，向下为y轴正方向。



<figure class="figure-container">
    <img src="/images/svg/20250506135205.png" alt="坐标区域" class="clickable-image">
    
</figure>

 
</p>
<h4 id="图形绘制">图形绘制</h4>
<p>要绘制一个图形就很简单了，比如绘制一个矩形，只要设置它的左上角的坐标，以及长宽高即可，如何要填充颜色可以使用fill属性。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">svg</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;200&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;200&#34;</span> <span class="na">xmlns</span><span class="o">=</span><span class="s">&#34;http://www.w3.org/2000/svg&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">rect</span> <span class="na">x</span><span class="o">=</span><span class="s">&#34;0&#34;</span> <span class="na">y</span><span class="o">=</span><span class="s">&#34;0&#34;</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;100&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;50&#34;</span> <span class="na">fill</span><span class="o">=</span><span class="s">&#34;blue&#34;</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">rect</span> <span class="na">x</span><span class="o">=</span><span class="s">&#34;100&#34;</span> <span class="na">y</span><span class="o">=</span><span class="s">&#34;100&#34;</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;80&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;30&#34;</span> <span class="na">fill</span><span class="o">=</span><span class="s">&#34;red&#34;</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">svg</span><span class="p">&gt;</span></span></span></code></pre></div>



<figure class="figure-container">
    <img src="/images/svg/20250506142545.png" alt="示例1" class="clickable-image">
    
</figure>

 

<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">svg</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;200&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;200&#34;</span> <span class="na">xmlns</span><span class="o">=</span><span class="s">&#34;http://www.w3.org/2000/svg&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">rect</span> <span class="na">x</span><span class="o">=</span><span class="s">&#34;0&#34;</span> <span class="na">y</span><span class="o">=</span><span class="s">&#34;0&#34;</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;100&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;50&#34;</span> <span class="na">fill</span><span class="o">=</span><span class="s">&#34;blue&#34;</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">rect</span> <span class="na">x</span><span class="o">=</span><span class="s">&#34;200&#34;</span> <span class="na">y</span><span class="o">=</span><span class="s">&#34;200&#34;</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;80&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;30&#34;</span> <span class="na">fill</span><span class="o">=</span><span class="s">&#34;red&#34;</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">svg</span><span class="p">&gt;</span></span></span></code></pre></div>



<figure class="figure-container">
    <img src="/images/svg/20250506142716.png" alt="示例2" class="clickable-image">
    
</figure>

 

<p>可以看到因为默认的裁切层区域与svg区域大小是一样的，且左上角在原点处。</p>
<h4 id="设置裁切层">设置裁切层</h4>
<p>上面的代码绘制了两个矩形，但是只显示一个矩形，另一个矩形在裁切层之外，所以默认是不显示的。那么如何同时显示两个矩形呢？可以设置裁切层的位置，把两个矩形都框住。使用viewBox属性来设置裁切层的位置和大小。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">svg</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;200&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;200&#34;</span> <span class="na">xmlns</span><span class="o">=</span><span class="s">&#34;http://www.w3.org/2000/svg&#34;</span> <span class="na">viewBox</span><span class="o">=</span><span class="s">&#34;0 0 300 300&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">rect</span> <span class="na">x</span><span class="o">=</span><span class="s">&#34;0&#34;</span> <span class="na">y</span><span class="o">=</span><span class="s">&#34;0&#34;</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;100&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;50&#34;</span> <span class="na">fill</span><span class="o">=</span><span class="s">&#34;blue&#34;</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">rect</span> <span class="na">x</span><span class="o">=</span><span class="s">&#34;200&#34;</span> <span class="na">y</span><span class="o">=</span><span class="s">&#34;200&#34;</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;80&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;30&#34;</span> <span class="na">fill</span><span class="o">=</span><span class="s">&#34;red&#34;</span> <span class="p">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">svg</span><span class="p">&gt;</span></span></span></code></pre></div>



<figure class="figure-container">
    <img src="/images/svg/20250506143054.png" alt="示例3" class="clickable-image">
    
</figure>

 

<p>如果裁切层大小与svg区域大小相同，那正好，只要把画布整体平移，使裁切层与svg区域重合即可，但是如果裁切层大小和svg区域大小不相同怎么办？</p>
<p>下面分两种情况讨论：</p>
<ol>
<li>svg区域与裁切层的长宽比相同时，通过等比例缩放来使裁切层与svg区域重合，很简单，不单独讨论。</li>
<li>长宽比不同时，有两种填充方式，且通过属性preserveAspectRatio来控制。</li>
</ol>
<h5 id="svg区域与裁切层的长宽比不相同">svg区域与裁切层的长宽比不相同</h5>
<p>下面的红色区域为SVG区域，绿色区域为裁切层。</p>
<ol>
<li>
<p>填满：裁切层完全覆盖svg区域，通过等比例缩放实现，这时裁切层内的内容不一定完全在svg区域内。比如下图中红色为svg区域，绿色为裁切层。填充时会将裁切层等比例放大知道能完全盖住svg区域。可以看到部分裁切层的内容不在svg区域内，最后不能显示。



<figure class="figure-container">
    <img src="/images/svg/20250506144105.png" alt="填满示例" class="clickable-image">
    
</figure>

 
</p>
</li>
<li>
<p>完整展示：确保裁切层内容能完全处于svg区域内。且某一个方向铺满。比如上面同样的情况，会把裁切层区域先缩小，然后平移到svg区域使上下方向铺满，至于对齐方式也可以控制.



<figure class="figure-container">
    <img src="/images/svg/20250506144337.png" alt="完整展示示例" class="clickable-image">
    
</figure>

 
</p>
</li>
<li>
<p>上述两种填充方式以及对齐都是通过属性preserveAspectRatio来控制的。</p>
</li>
</ol>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">对齐控制的值：xMinYMin，xMinYMax，xMaxYMax，xMaxYMin，xMinYMid，xMaxYMid，xMidYMid，xMidYMin，xMidYMax
</span></span><span class="line"><span class="cl">平铺：slice(铺满) ，meet(裁切层全入)
</span></span><span class="line"><span class="cl">默认：xMidYMid meet</span></span></code></pre></div>



<figure class="figure-container">
    <img src="/images/svg/20250506145205.png" alt="对齐示例" class="clickable-image">
    
</figure>

 


  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> Jan 1, 2024
  </footer>
</article>
          </section>
          </section>
        </div>
      </main>
    </div>
    <script src="/js/clipboard/clipboard.min.js?1747202925" defer></script>
    <script src="/js/perfect-scrollbar/perfect-scrollbar.min.js?1747202925" defer></script>
    <script src="/js/js-yaml/js-yaml.min.js?1747202925" defer></script>
    <script src="/js/d3/d3-color.min.js?1747202925" defer></script>
    <script src="/js/d3/d3-dispatch.min.js?1747202925" defer></script>
    <script src="/js/d3/d3-drag.min.js?1747202925" defer></script>
    <script src="/js/d3/d3-ease.min.js?1747202925" defer></script>
    <script src="/js/d3/d3-interpolate.min.js?1747202925" defer></script>
    <script src="/js/d3/d3-selection.min.js?1747202925" defer></script>
    <script src="/js/d3/d3-timer.min.js?1747202925" defer></script>
    <script src="/js/d3/d3-transition.min.js?1747202925" defer></script>
    <script src="/js/d3/d3-zoom.min.js?1747202925" defer></script>
    <script src="/js/mermaid/mermaid.min.js?1747202925" defer></script>
    <script>
      window.relearn.themeUseMermaid = JSON.parse("{}");
    </script>
    <script src="/js/theme.js?1747202925" defer></script>
  </body>
</html>
